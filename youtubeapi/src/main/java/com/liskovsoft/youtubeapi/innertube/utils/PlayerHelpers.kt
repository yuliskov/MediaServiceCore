package com.liskovsoft.youtubeapi.innertube.utils

import com.liskovsoft.sharedutils.helpers.Helpers
import com.liskovsoft.youtubeapi.common.models.gen.getText
import com.liskovsoft.youtubeapi.innertube.models.CaptionTrack
import com.liskovsoft.youtubeapi.innertube.models.PlayerResult
import com.liskovsoft.youtubeapi.innertube.models.StreamingFormat
import com.liskovsoft.youtubeapi.videoinfo.models.TranslatedCaptionTrack
import java.util.regex.Pattern

private val tagPattern = Pattern.compile("\\(.*\\)$")

internal fun PlayerResult.getVideoPlaybackUstreamerConfig() = playerConfig?.mediaCommonConfig?.mediaUstreamerRequestConfig?.videoPlaybackUstreamerConfig
internal fun PlayerResult.getServerAbrStreamingUrl() = streamingData?.serverAbrStreamingUrl
internal fun PlayerResult.getAdaptiveFormats() = streamingData?.adaptiveFormats
internal fun PlayerResult.getLegacyFormats() = streamingData?.formats
internal fun PlayerResult.getLoudnessDb() = playerConfig?.audioConfig?.loudnessDb ?: 0f
internal fun PlayerResult.getStoryboardSpec() = storyboards?.let { it.playerStoryboardSpecRenderer ?: it.playerLiveStoryboardSpecRenderer }?.spec
internal fun PlayerResult.getTrailerVideoId() = playabilityStatus?.errorScreen?.playerLegacyDesktopYpcTrailerRenderer?.trailerVideoId
internal fun PlayerResult.getPlayabilityStatus() = playabilityStatus?.status
internal fun PlayerResult.getPlayabilityReason() = playabilityStatus?.reason
internal fun PlayerResult.getPlayabilityDescription() = playabilityStatus?.errorScreen?.playerErrorMessageRenderer?.subreason?.getText()
internal fun PlayerResult.isPlayableInEmbed() = playabilityStatus?.playableInEmbed ?: false
internal fun PlayerResult.getStartTimestamp() = microformat?.playerMicroformatRenderer?.liveBroadcastDetails?.startTimestamp
internal fun PlayerResult.getUploadDate() = microformat?.playerMicroformatRenderer?.uploadDate
internal fun PlayerResult.getPaidContentText() = paidContentOverlay?.paidContentOverlayRenderer?.text?.getText()
internal fun PlayerResult.getWatchTimeUrl() = playbackTracking?.videostatsWatchtimeUrl?.baseUrl
private fun PlayerResult.getCaptionTracks() = captions?.playerCaptionsTracklistRenderer?.captionTracks
private fun PlayerResult.getTranslationLanguages() = captions?.playerCaptionsTracklistRenderer?.translationLanguages
internal fun PlayerResult.getMergeCaptionTracks(): List<CaptionTrack>? {
    val captionsTracks = getCaptionTracks()?.toMutableList()
    val translationLanguages = getTranslationLanguages()

    if (translationLanguages != null && captionsTracks != null) {
        val originTrack = findOriginTrack(captionsTracks)
        val tag = Helpers.runMultiMatcher(originTrack.getName(), tagPattern)
        for (language in translationLanguages) {
            // TODO: implement TranslatedCaptionTrack
            //captionsTracks.add(TranslatedCaptionTrack(originTrack, language, tag));
        }
    }
    
    return captionsTracks
}
private fun findOriginTrack(captionTracks: List<CaptionTrack>): CaptionTrack {
    var result: CaptionTrack? = null

    for (track in captionTracks) {
        if (!track.isAutogenerated()) {
            result = track;
            break;
        }
    }

    return result ?: captionTracks[0];
}

private const val FORMAT_STREAM_TYPE_OTF = "FORMAT_STREAM_TYPE_OTF"

internal fun StreamingFormat.isBroken() = Helpers.allNulls(url, cipher, signatureCipher)
internal fun StreamingFormat.hasRange() = indexRange != null || initRange != null
internal fun StreamingFormat.getIndexRange() = indexRange?.toRangeString()
internal fun StreamingFormat.getInitRange() = initRange?.toRangeString()
internal fun StreamingFormat.isOtf() = type == FORMAT_STREAM_TYPE_OTF

internal fun StreamingFormat.Range.toRangeString() = if (start == null || end == null) "" else "$start-$end"


private const val TYPE_ASR = "asr"

internal fun CaptionTrack.getName(): String? {
    val name = name?.getText()
    return if (isAutogenerated() && name != null) name + TranslatedCaptionTrack.TRANSLATE_MARKER else name
}
internal fun CaptionTrack.isAutogenerated(): Boolean = TYPE_ASR == kind