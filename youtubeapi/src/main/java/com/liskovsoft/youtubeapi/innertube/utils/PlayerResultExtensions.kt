package com.liskovsoft.youtubeapi.innertube.utils

import com.liskovsoft.googlecommon.common.helpers.YouTubeHelper
import com.liskovsoft.sharedutils.helpers.Helpers
import com.liskovsoft.sharedutils.querystringparser.UrlQueryString
import com.liskovsoft.sharedutils.querystringparser.UrlQueryStringFactory
import com.liskovsoft.youtubeapi.common.models.gen.TextItem
import com.liskovsoft.youtubeapi.common.models.gen.getText
import com.liskovsoft.youtubeapi.innertube.models.CaptionTrack
import com.liskovsoft.youtubeapi.innertube.models.PlayerResult
import com.liskovsoft.youtubeapi.innertube.models.StreamingFormat
import com.liskovsoft.youtubeapi.videoinfo.models.CaptionTrack.CaptionFormat
import java.util.regex.Pattern

private val tagPattern = Pattern.compile("\\(.*\\)$")

internal fun PlayerResult.getVideoPlaybackUstreamerConfig() = playerConfig?.mediaCommonConfig?.mediaUstreamerRequestConfig?.videoPlaybackUstreamerConfig
internal fun PlayerResult.getServerAbrStreamingUrl() = streamingData?.serverAbrStreamingUrl
internal fun PlayerResult.getAdaptiveFormats() = streamingData?.adaptiveFormats
internal fun PlayerResult.getLegacyFormats() = streamingData?.formats
internal fun PlayerResult.getLoudnessDb() = playerConfig?.audioConfig?.loudnessDb ?: 0f
internal fun PlayerResult.getStoryboardSpec() = storyboards?.let { it.playerStoryboardSpecRenderer ?: it.playerLiveStoryboardSpecRenderer }?.spec
internal fun PlayerResult.getTrailerVideoId() = playabilityStatus?.errorScreen?.playerLegacyDesktopYpcTrailerRenderer?.trailerVideoId
internal fun PlayerResult.getPlayabilityStatus() = playabilityStatus?.status
internal fun PlayerResult.getPlayabilityReason() = playabilityStatus?.reason
internal fun PlayerResult.getPlayabilityDescription() = playabilityStatus?.errorScreen?.playerErrorMessageRenderer?.subreason?.getText()
internal fun PlayerResult.isPlayableInEmbed() = playabilityStatus?.playableInEmbed ?: false
internal fun PlayerResult.getStartTimestamp() = microformat?.playerMicroformatRenderer?.liveBroadcastDetails?.startTimestamp
internal fun PlayerResult.getUploadDate() = microformat?.playerMicroformatRenderer?.uploadDate
internal fun PlayerResult.getPaidContentText() = paidContentOverlay?.paidContentOverlayRenderer?.text?.getText()
internal fun PlayerResult.getWatchTimeUrl() = playbackTracking?.videostatsWatchtimeUrl?.baseUrl
private fun PlayerResult.getCaptionTracks() = captions?.playerCaptionsTracklistRenderer?.captionTracks
private fun PlayerResult.getTranslationLanguages() = captions?.playerCaptionsTracklistRenderer?.translationLanguages
internal fun PlayerResult.getMergeCaptionTracks(): List<CaptionTrack>? {
    val translationLanguages = getTranslationLanguages()
    val captionTracks = getCaptionTracks()

    if (translationLanguages == null || captionTracks == null)
        return captionTracks

    val resultTracks = captionTracks.toMutableList()

    val originTrack = findOriginTrack(resultTracks)
    val tag = Helpers.runMultiMatcher(originTrack.getName(), tagPattern)
    for (language in translationLanguages) {
        // Don't try to translate the same lang or you'll get a mess
        val baseUrl = if (originTrack.languageCode == language.languageCode) originTrack.baseUrl
            else "${originTrack.baseUrl}&tlang=${language.languageCode}"
        resultTracks.add(CaptionTrack(
            baseUrl,
            originTrack.isTranslatable,
            language.languageCode,
            originTrack.vssId,
            TextItem(null, YouTubeHelper.exoNameFix(language.languageName?.getText()), null, null),
            TYPE_ASR // add autogenerated marker
        ))
    }

    return resultTracks
}
private fun findOriginTrack(captionTracks: List<CaptionTrack>): CaptionTrack {
    var result: CaptionTrack? = null

    for (track in captionTracks) {
        if (!track.isAutogenerated()) {
            result = track;
            break;
        }
    }

    return result ?: captionTracks[0];
}

private const val FORMAT_STREAM_TYPE_OTF = "FORMAT_STREAM_TYPE_OTF"

internal fun StreamingFormat.isBroken() = Helpers.allNulls(url, cipher, signatureCipher)
internal fun StreamingFormat.hasRange() = indexRange != null || initRange != null
internal fun StreamingFormat.getIndexRange() = indexRange?.toRangeString()
internal fun StreamingFormat.getInitRange() = initRange?.toRangeString()
internal fun StreamingFormat.isOtf() = type == FORMAT_STREAM_TYPE_OTF

internal fun StreamingFormat.Range.toRangeString() = if (start == null || end == null) "" else "$start-$end"


const val TRANSLATE_MARKER = "*"
private const val TYPE_ASR = "asr"
var selectedCaptionFormat = CaptionFormat.TTML

internal fun CaptionTrack.getName(): String? {
    val name = name?.getText()
    return if (isAutogenerated() && name != null) name + TRANSLATE_MARKER else name
}
internal fun CaptionTrack.isAutogenerated(): Boolean = TYPE_ASR == kind
internal fun CaptionTrack.getMimeType() = selectedCaptionFormat.mimeType
internal fun CaptionTrack.getCodecs() = selectedCaptionFormat.codecs
internal fun CaptionTrack.getBaseUrl(): String? {
    val baseUrlQuery = getBaseUrlQuery() ?: return null

    baseUrlQuery.set("fmt", selectedCaptionFormat.name)

    return baseUrlQuery.toString()
}
private fun CaptionTrack.getBaseUrlQuery(): UrlQueryString? {
    if (baseUrl == null) {
        return null
    }

    var newBaseUrl: String? = null

    if (baseUrl.startsWith("/")) { // Fix relative urls (mweb client)
        newBaseUrl = "https://www.youtube.com$baseUrl"
    }

    return UrlQueryStringFactory.parse(newBaseUrl ?: baseUrl)
}